/*
 * SPDX-License-Identifier: MIT
 *
 * Copyright (C) 2011-2012 Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
 * Copyright (C) 2019 Michael Jeanson <mjeanson@efficios.com>
 */

#include <assert.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <urcu/compiler.h>

#define URCU_CPUMASK_SIZE 4096

#if defined(HAVE_SYSCONF)
static inline int get_num_possible_cpus_sysconf(void)
{
	return sysconf(_SC_NPROCESSORS_CONF);
}
#else
/*
 * On platforms without sysconf(), always return -1.
 */
static inline int get_num_possible_cpus_sysconf(void)
{
	return -1;
}
#endif

#ifdef __linux__
/*
 * Get the highest CPU id from sysfs.
 *
 * Iterate on all the folders in "/sys/devices/system/cpu" that start with
 * "cpu" followed by an integer, keep the highest CPU id encountered during
 * this iteration and add 1 to get a number of CPUs.
 *
 * Returns the highest CPU id, or -1 on error.
 */
static inline int _get_max_cpuid_from_sysfs(const char *path)
{
	long max_cpuid = -1;

	DIR *cpudir;
	struct dirent *entry;

	assert(path);

	cpudir = opendir(path);
	if (cpudir == NULL)
		goto end;

	/*
	 * Iterate on all directories named "cpu" followed by an integer.
	 */
	while ((entry = readdir(cpudir))) {
		if (entry->d_type == DT_DIR &&
			strncmp(entry->d_name, "cpu", 3) == 0) {

			char *endptr;
			long cpu_id;

			cpu_id = strtol(entry->d_name + 3, &endptr, 10);
			if ((cpu_id < LONG_MAX) && (endptr != entry->d_name + 3)
					&& (*endptr == '\0')) {
				if (cpu_id > max_cpuid)
					max_cpuid = cpu_id;
			}
		}
	}

	if (closedir(cpudir))
		perror("closedir");

	/*
	 * If the max CPU id is out of bound, set it to -1 so it results in a
	 * CPU num of 0.
	 */
	if (max_cpuid < 0 || max_cpuid > INT_MAX)
		max_cpuid = -1;

end:
	return max_cpuid;
}

static inline int get_max_cpuid_from_sysfs(void)
{
	return _get_max_cpuid_from_sysfs("/sys/devices/system/cpu");
}


/*
 * As a fallback to parsing the CPU mask in "/sys/devices/system/cpu/possible",
 * iterate on all the folders in "/sys/devices/system/cpu" that start with
 * "cpu" followed by an integer, keep the highest CPU id encountered during
 * this iteration and add 1 to get a number of CPUs.
 *
 * Then get the value from sysconf(_SC_NPROCESSORS_CONF) as a fallback and
 * return the highest one.
 *
 * On Linux, using the value from sysconf can be unreliable since the way it
 * counts CPUs varies between C libraries and even between versions of the same
 * library. If we used it directly, getcpu() could return a value greater than
 * this sysconf, in which case the arrays indexed by processor would overflow.
 *
 * As another example, the MUSL libc implementation of the _SC_NPROCESSORS_CONF
 * sysconf does not return the number of configured CPUs in the system but
 * relies on the cpu affinity mask of the current task.
 *
 * Returns 0 or less on error.
 */
static inline int get_num_possible_cpus_fallback(void)
{
	/*
	 * Get the sysconf value as a last resort. Keep the highest number.
	 */
	return caa_max(get_num_possible_cpus_sysconf(), get_max_cpuid_from_sysfs() + 1);
}

/*
 * Get a CPU mask string from sysfs.
 *
 * buf: the buffer where the mask will be read.
 * max_bytes: the maximum number of bytes to write in the buffer.
 * path: file path to read the mask from.
 *
 * Returns the number of bytes read or -1 on error.
 */
static inline int get_cpu_mask_from_sysfs(char *buf, size_t max_bytes, const char *path)
{
	ssize_t bytes_read = 0;
	size_t total_bytes_read = 0;
	int fd = -1, ret = -1;

	assert(path);

	if (buf == NULL)
		goto end;

	fd = open(path, O_RDONLY);
	if (fd < 0)
		goto end;

	do {
		bytes_read = read(fd, buf + total_bytes_read,
				max_bytes - total_bytes_read);

		if (bytes_read < 0) {
			if (errno == EINTR) {
				continue;	/* retry operation */
			} else {
				goto end;
			}
		}

		total_bytes_read += bytes_read;
		assert(total_bytes_read <= max_bytes);
	} while (max_bytes > total_bytes_read && bytes_read != 0);

	/*
	 * Make sure the mask read is a null terminated string.
	 */
	if (total_bytes_read < max_bytes)
		buf[total_bytes_read] = '\0';
	else
		buf[max_bytes - 1] = '\0';

	if (total_bytes_read > INT_MAX)
		goto end;

	ret = (int) total_bytes_read;

end:
	if (fd >= 0 && close(fd) < 0)
		perror("close");

	return ret;
}

/*
 * Get the CPU possible mask string from sysfs.
 *
 * buf: the buffer where the mask will be read.
 * max_bytes: the maximum number of bytes to write in the buffer.
 *
 * Returns the number of bytes read or -1 on error.
 */
static inline int get_possible_cpu_mask_from_sysfs(char *buf, size_t max_bytes)
{
	return get_cpu_mask_from_sysfs(buf, max_bytes,
			"/sys/devices/system/cpu/possible");
}

/*
 * Get the highest CPU id from the possible CPU mask.
 *
 * pmask: the mask to parse.
 * len: the len of the mask excluding '\0'.
 *
 * Returns the highest CPU id from the mask or -1 on error.
 */
static inline int get_max_cpuid_from_mask(const char *pmask, size_t len)
{
	ssize_t i;
	unsigned long cpu_index;
	char *endptr;

	/* We need at least one char to read */
	if (len < 1)
		goto error;

	/* Start from the end to read the last CPU index. */
	for (i = len - 1; i > 0; i--) {
		/* Break when we hit the first separator. */
		if ((pmask[i] == ',') || (pmask[i] == '-')) {
			i++;
			break;
		}
	}

	cpu_index = strtoul(&pmask[i], &endptr, 10);

	if ((&pmask[i] != endptr) && (cpu_index < INT_MAX))
		return (int) cpu_index;

error:
	return -1;
}

/*
 * On Linux try sysfs first and fallback to sysconf.
 */
static inline int get_possible_cpus_array_len(void)
{
	int ret;
	char buf[URCU_CPUMASK_SIZE];

	/* Get the possible cpu mask from sysfs, fallback to sysconf. */
	ret = get_possible_cpu_mask_from_sysfs((char *) &buf, URCU_CPUMASK_SIZE);
	if (ret <= 0)
		goto fallback;

	/* Parse the possible cpu mask, on failure fallback to sysconf. */
	ret = get_max_cpuid_from_mask((char *) &buf, ret);
	if (ret >= 0) {
		/* Add 1 to convert from max cpuid to an array len. */
		ret++;
		goto end;
	}

fallback:
	/* Fallback to sysconf. */
	ret = get_num_possible_cpus_fallback();

end:
	return ret;
}
#else
/*
 * On other platforms, only use sysconf.
 */
static inline int get_possible_cpus_array_len(void)
{
	return get_num_possible_cpus_sysconf();
}
#endif
